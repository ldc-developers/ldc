// File generated by idgen.c
#include "id.h"
#include "identifier.h"
#include "lexer.h"
Identifier *Id::IUnknown;
Identifier *Id::Object;
Identifier *Id::object;
Identifier *Id::max;
Identifier *Id::min;
Identifier *Id::This;
Identifier *Id::ctor;
Identifier *Id::dtor;
Identifier *Id::cpctor;
Identifier *Id::_postblit;
Identifier *Id::classInvariant;
Identifier *Id::unitTest;
Identifier *Id::init;
Identifier *Id::size;
Identifier *Id::__sizeof;
Identifier *Id::alignof;
Identifier *Id::mangleof;
Identifier *Id::stringof;
Identifier *Id::tupleof;
Identifier *Id::length;
Identifier *Id::remove;
Identifier *Id::ptr;
Identifier *Id::funcptr;
Identifier *Id::dollar;
Identifier *Id::offset;
Identifier *Id::offsetof;
Identifier *Id::ModuleInfo;
Identifier *Id::ClassInfo;
Identifier *Id::classinfo;
Identifier *Id::typeinfo;
Identifier *Id::outer;
Identifier *Id::Exception;
Identifier *Id::Throwable;
Identifier *Id::withSym;
Identifier *Id::result;
Identifier *Id::returnLabel;
Identifier *Id::delegate;
Identifier *Id::line;
Identifier *Id::empty;
Identifier *Id::p;
Identifier *Id::coverage;
Identifier *Id::__vptr;
Identifier *Id::__monitor;
Identifier *Id::system;
Identifier *Id::TypeInfo;
Identifier *Id::TypeInfo_Class;
Identifier *Id::TypeInfo_Interface;
Identifier *Id::TypeInfo_Struct;
Identifier *Id::TypeInfo_Enum;
Identifier *Id::TypeInfo_Typedef;
Identifier *Id::TypeInfo_Pointer;
Identifier *Id::TypeInfo_Array;
Identifier *Id::TypeInfo_StaticArray;
Identifier *Id::TypeInfo_AssociativeArray;
Identifier *Id::TypeInfo_Function;
Identifier *Id::TypeInfo_Delegate;
Identifier *Id::TypeInfo_Tuple;
Identifier *Id::TypeInfo_Const;
Identifier *Id::TypeInfo_Invariant;
Identifier *Id::TypeInfo_Shared;
Identifier *Id::elements;
Identifier *Id::_arguments_typeinfo;
Identifier *Id::_arguments;
Identifier *Id::_argptr;
Identifier *Id::_match;
Identifier *Id::destroy;
Identifier *Id::postblit;
Identifier *Id::LINE;
Identifier *Id::FILE;
Identifier *Id::DATE;
Identifier *Id::TIME;
Identifier *Id::TIMESTAMP;
Identifier *Id::VENDOR;
Identifier *Id::VERSIONX;
Identifier *Id::EOFX;
Identifier *Id::nan;
Identifier *Id::infinity;
Identifier *Id::dig;
Identifier *Id::epsilon;
Identifier *Id::mant_dig;
Identifier *Id::max_10_exp;
Identifier *Id::max_exp;
Identifier *Id::min_10_exp;
Identifier *Id::min_exp;
Identifier *Id::re;
Identifier *Id::im;
Identifier *Id::C;
Identifier *Id::D;
Identifier *Id::Windows;
Identifier *Id::Pascal;
Identifier *Id::System;
Identifier *Id::exit;
Identifier *Id::success;
Identifier *Id::failure;
Identifier *Id::keys;
Identifier *Id::values;
Identifier *Id::rehash;
Identifier *Id::sort;
Identifier *Id::reverse;
Identifier *Id::dup;
Identifier *Id::idup;
Identifier *Id::___out;
Identifier *Id::___in;
Identifier *Id::__int;
Identifier *Id::__dollar;
Identifier *Id::__LOCAL_SIZE;
Identifier *Id::uadd;
Identifier *Id::neg;
Identifier *Id::com;
Identifier *Id::add;
Identifier *Id::add_r;
Identifier *Id::sub;
Identifier *Id::sub_r;
Identifier *Id::mul;
Identifier *Id::mul_r;
Identifier *Id::div;
Identifier *Id::div_r;
Identifier *Id::mod;
Identifier *Id::mod_r;
Identifier *Id::eq;
Identifier *Id::cmp;
Identifier *Id::iand;
Identifier *Id::iand_r;
Identifier *Id::ior;
Identifier *Id::ior_r;
Identifier *Id::ixor;
Identifier *Id::ixor_r;
Identifier *Id::shl;
Identifier *Id::shl_r;
Identifier *Id::shr;
Identifier *Id::shr_r;
Identifier *Id::ushr;
Identifier *Id::ushr_r;
Identifier *Id::cat;
Identifier *Id::cat_r;
Identifier *Id::assign;
Identifier *Id::addass;
Identifier *Id::subass;
Identifier *Id::mulass;
Identifier *Id::divass;
Identifier *Id::modass;
Identifier *Id::andass;
Identifier *Id::orass;
Identifier *Id::xorass;
Identifier *Id::shlass;
Identifier *Id::shrass;
Identifier *Id::ushrass;
Identifier *Id::catass;
Identifier *Id::postinc;
Identifier *Id::postdec;
Identifier *Id::index;
Identifier *Id::indexass;
Identifier *Id::slice;
Identifier *Id::sliceass;
Identifier *Id::call;
Identifier *Id::cast;
Identifier *Id::match;
Identifier *Id::next;
Identifier *Id::opIn;
Identifier *Id::opIn_r;
Identifier *Id::opStar;
Identifier *Id::opDot;
Identifier *Id::opImplicitCast;
Identifier *Id::classNew;
Identifier *Id::classDelete;
Identifier *Id::apply;
Identifier *Id::applyReverse;
Identifier *Id::Fempty;
Identifier *Id::Fhead;
Identifier *Id::Ftoe;
Identifier *Id::Fnext;
Identifier *Id::Fretreat;
Identifier *Id::adDup;
Identifier *Id::adReverse;
Identifier *Id::aaLen;
Identifier *Id::aaKeys;
Identifier *Id::aaValues;
Identifier *Id::aaRehash;
Identifier *Id::GNU_asm;
Identifier *Id::lib;
Identifier *Id::msg;
Identifier *Id::startaddress;
Identifier *Id::intrinsic;
Identifier *Id::va_intrinsic;
Identifier *Id::no_typeinfo;
Identifier *Id::no_moduleinfo;
Identifier *Id::Alloca;
Identifier *Id::vastart;
Identifier *Id::vacopy;
Identifier *Id::vaend;
Identifier *Id::vaarg;
Identifier *Id::ldc;
Identifier *Id::allow_inline;
Identifier *Id::llvm_inline_asm;
Identifier *Id::tohash;
Identifier *Id::tostring;
Identifier *Id::getmembers;
Identifier *Id::main;
Identifier *Id::WinMain;
Identifier *Id::DllMain;
Identifier *Id::tls_get_addr;
Identifier *Id::std;
Identifier *Id::math;
Identifier *Id::sin;
Identifier *Id::cos;
Identifier *Id::tan;
Identifier *Id::_sqrt;
Identifier *Id::fabs;
Identifier *Id::isAbstractClass;
Identifier *Id::isArithmetic;
Identifier *Id::isAssociativeArray;
Identifier *Id::isFinalClass;
Identifier *Id::isFloating;
Identifier *Id::isIntegral;
Identifier *Id::isScalar;
Identifier *Id::isStaticArray;
Identifier *Id::isUnsigned;
Identifier *Id::isVirtualFunction;
Identifier *Id::isAbstractFunction;
Identifier *Id::isFinalFunction;
Identifier *Id::hasMember;
Identifier *Id::getMember;
Identifier *Id::getVirtualFunctions;
Identifier *Id::classInstanceSize;
Identifier *Id::allMembers;
Identifier *Id::derivedMembers;
Identifier *Id::isSame;
Identifier *Id::compiles;
void Id::initialize()
{
    IUnknown = Lexer::idPool("IUnknown");
    Object = Lexer::idPool("Object");
    object = Lexer::idPool("object");
    max = Lexer::idPool("max");
    min = Lexer::idPool("min");
    This = Lexer::idPool("this");
    ctor = Lexer::idPool("__ctor");
    dtor = Lexer::idPool("__dtor");
    cpctor = Lexer::idPool("__cpctor");
    _postblit = Lexer::idPool("__postblit");
    classInvariant = Lexer::idPool("__invariant");
    unitTest = Lexer::idPool("__unitTest");
    init = Lexer::idPool("init");
    size = Lexer::idPool("size");
    __sizeof = Lexer::idPool("sizeof");
    alignof = Lexer::idPool("alignof");
    mangleof = Lexer::idPool("mangleof");
    stringof = Lexer::idPool("stringof");
    tupleof = Lexer::idPool("tupleof");
    length = Lexer::idPool("length");
    remove = Lexer::idPool("remove");
    ptr = Lexer::idPool("ptr");
    funcptr = Lexer::idPool("funcptr");
    dollar = Lexer::idPool("__dollar");
    offset = Lexer::idPool("offset");
    offsetof = Lexer::idPool("offsetof");
    ModuleInfo = Lexer::idPool("ModuleInfo");
    ClassInfo = Lexer::idPool("ClassInfo");
    classinfo = Lexer::idPool("classinfo");
    typeinfo = Lexer::idPool("typeinfo");
    outer = Lexer::idPool("outer");
    Exception = Lexer::idPool("Exception");
    Throwable = Lexer::idPool("Throwable");
    withSym = Lexer::idPool("__withSym");
    result = Lexer::idPool("__result");
    returnLabel = Lexer::idPool("__returnLabel");
    delegate = Lexer::idPool("delegate");
    line = Lexer::idPool("line");
    empty = Lexer::idPool("");
    p = Lexer::idPool("p");
    coverage = Lexer::idPool("__coverage");
    __vptr = Lexer::idPool("__vptr");
    __monitor = Lexer::idPool("__monitor");
    system = Lexer::idPool("system");
    TypeInfo = Lexer::idPool("TypeInfo");
    TypeInfo_Class = Lexer::idPool("TypeInfo_Class");
    TypeInfo_Interface = Lexer::idPool("TypeInfo_Interface");
    TypeInfo_Struct = Lexer::idPool("TypeInfo_Struct");
    TypeInfo_Enum = Lexer::idPool("TypeInfo_Enum");
    TypeInfo_Typedef = Lexer::idPool("TypeInfo_Typedef");
    TypeInfo_Pointer = Lexer::idPool("TypeInfo_Pointer");
    TypeInfo_Array = Lexer::idPool("TypeInfo_Array");
    TypeInfo_StaticArray = Lexer::idPool("TypeInfo_StaticArray");
    TypeInfo_AssociativeArray = Lexer::idPool("TypeInfo_AssociativeArray");
    TypeInfo_Function = Lexer::idPool("TypeInfo_Function");
    TypeInfo_Delegate = Lexer::idPool("TypeInfo_Delegate");
    TypeInfo_Tuple = Lexer::idPool("TypeInfo_Tuple");
    TypeInfo_Const = Lexer::idPool("TypeInfo_Const");
    TypeInfo_Invariant = Lexer::idPool("TypeInfo_Invariant");
    TypeInfo_Shared = Lexer::idPool("TypeInfo_Shared");
    elements = Lexer::idPool("elements");
    _arguments_typeinfo = Lexer::idPool("_arguments_typeinfo");
    _arguments = Lexer::idPool("_arguments");
    _argptr = Lexer::idPool("_argptr");
    _match = Lexer::idPool("_match");
    destroy = Lexer::idPool("destroy");
    postblit = Lexer::idPool("postblit");
    LINE = Lexer::idPool("__LINE__");
    FILE = Lexer::idPool("__FILE__");
    DATE = Lexer::idPool("__DATE__");
    TIME = Lexer::idPool("__TIME__");
    TIMESTAMP = Lexer::idPool("__TIMESTAMP__");
    VENDOR = Lexer::idPool("__VENDOR__");
    VERSIONX = Lexer::idPool("__VERSION__");
    EOFX = Lexer::idPool("__EOF__");
    nan = Lexer::idPool("nan");
    infinity = Lexer::idPool("infinity");
    dig = Lexer::idPool("dig");
    epsilon = Lexer::idPool("epsilon");
    mant_dig = Lexer::idPool("mant_dig");
    max_10_exp = Lexer::idPool("max_10_exp");
    max_exp = Lexer::idPool("max_exp");
    min_10_exp = Lexer::idPool("min_10_exp");
    min_exp = Lexer::idPool("min_exp");
    re = Lexer::idPool("re");
    im = Lexer::idPool("im");
    C = Lexer::idPool("C");
    D = Lexer::idPool("D");
    Windows = Lexer::idPool("Windows");
    Pascal = Lexer::idPool("Pascal");
    System = Lexer::idPool("System");
    exit = Lexer::idPool("exit");
    success = Lexer::idPool("success");
    failure = Lexer::idPool("failure");
    keys = Lexer::idPool("keys");
    values = Lexer::idPool("values");
    rehash = Lexer::idPool("rehash");
    sort = Lexer::idPool("sort");
    reverse = Lexer::idPool("reverse");
    dup = Lexer::idPool("dup");
    idup = Lexer::idPool("idup");
    ___out = Lexer::idPool("out");
    ___in = Lexer::idPool("in");
    __int = Lexer::idPool("int");
    __dollar = Lexer::idPool("$");
    __LOCAL_SIZE = Lexer::idPool("__LOCAL_SIZE");
    uadd = Lexer::idPool("opPos");
    neg = Lexer::idPool("opNeg");
    com = Lexer::idPool("opCom");
    add = Lexer::idPool("opAdd");
    add_r = Lexer::idPool("opAdd_r");
    sub = Lexer::idPool("opSub");
    sub_r = Lexer::idPool("opSub_r");
    mul = Lexer::idPool("opMul");
    mul_r = Lexer::idPool("opMul_r");
    div = Lexer::idPool("opDiv");
    div_r = Lexer::idPool("opDiv_r");
    mod = Lexer::idPool("opMod");
    mod_r = Lexer::idPool("opMod_r");
    eq = Lexer::idPool("opEquals");
    cmp = Lexer::idPool("opCmp");
    iand = Lexer::idPool("opAnd");
    iand_r = Lexer::idPool("opAnd_r");
    ior = Lexer::idPool("opOr");
    ior_r = Lexer::idPool("opOr_r");
    ixor = Lexer::idPool("opXor");
    ixor_r = Lexer::idPool("opXor_r");
    shl = Lexer::idPool("opShl");
    shl_r = Lexer::idPool("opShl_r");
    shr = Lexer::idPool("opShr");
    shr_r = Lexer::idPool("opShr_r");
    ushr = Lexer::idPool("opUShr");
    ushr_r = Lexer::idPool("opUShr_r");
    cat = Lexer::idPool("opCat");
    cat_r = Lexer::idPool("opCat_r");
    assign = Lexer::idPool("opAssign");
    addass = Lexer::idPool("opAddAssign");
    subass = Lexer::idPool("opSubAssign");
    mulass = Lexer::idPool("opMulAssign");
    divass = Lexer::idPool("opDivAssign");
    modass = Lexer::idPool("opModAssign");
    andass = Lexer::idPool("opAndAssign");
    orass = Lexer::idPool("opOrAssign");
    xorass = Lexer::idPool("opXorAssign");
    shlass = Lexer::idPool("opShlAssign");
    shrass = Lexer::idPool("opShrAssign");
    ushrass = Lexer::idPool("opUShrAssign");
    catass = Lexer::idPool("opCatAssign");
    postinc = Lexer::idPool("opPostInc");
    postdec = Lexer::idPool("opPostDec");
    index = Lexer::idPool("opIndex");
    indexass = Lexer::idPool("opIndexAssign");
    slice = Lexer::idPool("opSlice");
    sliceass = Lexer::idPool("opSliceAssign");
    call = Lexer::idPool("opCall");
    cast = Lexer::idPool("opCast");
    match = Lexer::idPool("opMatch");
    next = Lexer::idPool("opNext");
    opIn = Lexer::idPool("opIn");
    opIn_r = Lexer::idPool("opIn_r");
    opStar = Lexer::idPool("opStar");
    opDot = Lexer::idPool("opDot");
    opImplicitCast = Lexer::idPool("opImplicitCast");
    classNew = Lexer::idPool("new");
    classDelete = Lexer::idPool("delete");
    apply = Lexer::idPool("opApply");
    applyReverse = Lexer::idPool("opApplyReverse");
    Fempty = Lexer::idPool("empty");
    Fhead = Lexer::idPool("front");
    Ftoe = Lexer::idPool("back");
    Fnext = Lexer::idPool("popFront");
    Fretreat = Lexer::idPool("popBack");
    adDup = Lexer::idPool("_adDupT");
    adReverse = Lexer::idPool("_adReverse");
    aaLen = Lexer::idPool("_aaLen");
    aaKeys = Lexer::idPool("_aaKeys");
    aaValues = Lexer::idPool("_aaValues");
    aaRehash = Lexer::idPool("_aaRehash");
    GNU_asm = Lexer::idPool("GNU_asm");
    lib = Lexer::idPool("lib");
    msg = Lexer::idPool("msg");
    startaddress = Lexer::idPool("startaddress");
    intrinsic = Lexer::idPool("intrinsic");
    va_intrinsic = Lexer::idPool("va_intrinsic");
    no_typeinfo = Lexer::idPool("no_typeinfo");
    no_moduleinfo = Lexer::idPool("no_moduleinfo");
    Alloca = Lexer::idPool("alloca");
    vastart = Lexer::idPool("va_start");
    vacopy = Lexer::idPool("va_copy");
    vaend = Lexer::idPool("va_end");
    vaarg = Lexer::idPool("va_arg");
    ldc = Lexer::idPool("ldc");
    allow_inline = Lexer::idPool("allow_inline");
    llvm_inline_asm = Lexer::idPool("llvm_inline_asm");
    tohash = Lexer::idPool("toHash");
    tostring = Lexer::idPool("toString");
    getmembers = Lexer::idPool("getMembers");
    main = Lexer::idPool("main");
    WinMain = Lexer::idPool("WinMain");
    DllMain = Lexer::idPool("DllMain");
    tls_get_addr = Lexer::idPool("___tls_get_addr");
    std = Lexer::idPool("std");
    math = Lexer::idPool("math");
    sin = Lexer::idPool("sin");
    cos = Lexer::idPool("cos");
    tan = Lexer::idPool("tan");
    _sqrt = Lexer::idPool("sqrt");
    fabs = Lexer::idPool("fabs");
    isAbstractClass = Lexer::idPool("isAbstractClass");
    isArithmetic = Lexer::idPool("isArithmetic");
    isAssociativeArray = Lexer::idPool("isAssociativeArray");
    isFinalClass = Lexer::idPool("isFinalClass");
    isFloating = Lexer::idPool("isFloating");
    isIntegral = Lexer::idPool("isIntegral");
    isScalar = Lexer::idPool("isScalar");
    isStaticArray = Lexer::idPool("isStaticArray");
    isUnsigned = Lexer::idPool("isUnsigned");
    isVirtualFunction = Lexer::idPool("isVirtualFunction");
    isAbstractFunction = Lexer::idPool("isAbstractFunction");
    isFinalFunction = Lexer::idPool("isFinalFunction");
    hasMember = Lexer::idPool("hasMember");
    getMember = Lexer::idPool("getMember");
    getVirtualFunctions = Lexer::idPool("getVirtualFunctions");
    classInstanceSize = Lexer::idPool("classInstanceSize");
    allMembers = Lexer::idPool("allMembers");
    derivedMembers = Lexer::idPool("derivedMembers");
    isSame = Lexer::idPool("isSame");
    compiles = Lexer::idPool("compiles");
}

//===-- abi-ppc64.cpp -----------------------------------------------------===//
//
//                         LDC ? the LLVM D compiler
//
// This file is distributed under the BSD-style LDC license. See the LICENSE
// file for details.
//
//===----------------------------------------------------------------------===//
//
// The ABI implementation used for 32/64 bit big-endian PowerPC targets.
//
// The System V Application Binary Interface PowerPC Processor Supplement can be
// found here:
// http://refspecs.linuxfoundation.org/elf/elfspec_ppc.pdf
//
// The PowerOpen 64bit ABI can be found here:
// http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi-1.9.html
// http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi-1.9.pdf
//
//===----------------------------------------------------------------------===//

#include "gen/abi.h"
#include "gen/abi-generic.h"
#include "gen/abi-ppc.h"
#include "gen/dvalue.h"
#include "gen/irstate.h"
#include "gen/llvmhelpers.h"
#include "gen/tollvm.h"

struct PPCTargetABI : TargetABI {
  ExplicitByvalRewrite byvalRewrite;
  CompositeToArray32 compositeToArray32;
  CompositeToArray64 compositeToArray64;
  IntegerRewrite integerRewrite;
  const bool Is64Bit;

  explicit PPCTargetABI(const bool Is64Bit) : Is64Bit(Is64Bit) {}

  bool returnInArg(TypeFunction *tf) override {
    if (tf->isref) {
      return false;
    }

    // FIXME
    Type *rt = tf->next->toBasetype();
    if (tf->linkage == LINKd)
      return rt->ty == Tsarray || rt->ty == Tstruct;

    // The ABI specifies that aggregates of size 8 bytes or less are
    // returned in r3/r4 (ppc) or in r3 (ppc64). Looking at the IR
    // generated by clang this seems not to be implemented. Regardless
    // of size, the aggregate is always returned as sret.
    return rt->ty == Tsarray || rt->ty == Tstruct;
  }

  bool passByVal(Type *t) override {
    // On ppc, aggregates are always passed as an indirect value.
    // On ppc64, they are always passed by value. However, clang
    // used byval for type > 64 bytes.
    t = t->toBasetype();
    return (t->ty == Tsarray || t->ty == Tstruct) && (!Is64Bit || t->size() > 64);
  }

  void rewriteFunctionType(TypeFunction *tf, IrFuncTy &fty) override {
    // RETURN VALUE
    Type *retTy = fty.ret->type->toBasetype();
    if (!fty.ret->byref) {
      if (retTy->ty == Tstruct || retTy->ty == Tsarray) {
        if (canRewriteAsInt(retTy, Is64Bit)) {
          fty.ret->rewrite = &integerRewrite;
          fty.ret->ltype = integerRewrite.type(fty.ret->type);
        } else {
          if (Is64Bit) {
            fty.ret->rewrite = &compositeToArray64;
            fty.ret->ltype =
                compositeToArray64.type(fty.ret->type);
          } else {
            fty.ret->rewrite = &compositeToArray32;
            fty.ret->ltype =
                compositeToArray32.type(fty.ret->type);
          }
        }
      } else if (retTy->isintegral())
        fty.ret->attrs.add(retTy->isunsigned() ? LLAttribute::ZExt
                                               : LLAttribute::SExt);
    }
    // EXPLICIT PARAMETERS
    for (auto arg : fty.args) {
      if (!arg->byref) {
        rewriteArgument(fty, *arg);
      }
    }
  }

  void rewriteArgument(IrFuncTy &fty, IrFuncTyArg &arg) override {
    Type *ty = arg.type->toBasetype();

    if (ty->ty == Tstruct || ty->ty == Tsarray) {
      if (canRewriteAsInt(ty, Is64Bit)) {
        arg.rewrite = &integerRewrite;
        arg.ltype = integerRewrite.type(arg.type);
      } else {
        if (Is64Bit) {
          arg.rewrite = &compositeToArray64;
          arg.ltype = compositeToArray64.type(arg.type);
        } else {
          arg.rewrite = &compositeToArray32;
          arg.ltype = compositeToArray32.type(arg.type);
        }
      }
    } else if (ty->isintegral())
      arg.attrs.add(ty->isunsigned() ? LLAttribute::ZExt : LLAttribute::SExt);
  }
};

// The public getter for abi.cpp
TargetABI *getPPCTargetABI(bool Is64Bit) {
  return new PPCTargetABI(Is64Bit);
}
